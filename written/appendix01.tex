\appendix

\addsec{Anhang A: Lednicer- und Selig-Format}
\label{appendix:a}

Es folgt eine Gegenüberstellung des Selig-Formats (links) mit dem Lednicer-Format (rechts) am Beispiel des NACA M13-Profils.

\begin{minipage}{0.45\textwidth}
\verbatiminput{dataformats/m13_selig.DAT}
\end{minipage}
    \hfill
\begin{minipage}{0.45\textwidth}
\verbatiminput{dataformats/m13_lednicer.DAT}
\end{minipage}

\newpage
\addsec{Anhang B: Beispielausgabe der Methode .write\_panels()}
\label{appendix:b}
Hier ist die Ausgabe der ersten 30 Zeilen der AirfoilProfile-Methode .write\_panels() gezeigt, am Beispiel des NASA: HSNLF(1)-0213 Profils.

\verbatiminput{writtenvals/hsnlf213_vals.csv}

\newpage
\addsec{Anhang C: Codeausschnitte}
\label{appendix:c}
Hier sind ausgewählte Codeausschnitte gezeigt, welche zur Lösung der Problemstellungen geschrieben wurden.
\subsubsection{Die Klasse Panel}
Die Klasse Panel modelliert die Panels $\mathcal{C}_i$ eines gegebenen Profils. Gespeichert werden neben den charakteristischen Parametern $X_i, Y_i, \theta _i, l_i$ auch der Normalwinkel des Panels $\delta_i$, welcher aus dem Profil herauszeigt. Ebenso wird die Panelposition als Ober- oder Unterseite bestimmt (für einige besondere Profile ist auch ein Wert "vertical" für komplett senkrechte Panele möglich). Ebenso gespeichert wird die Quellbelegung $q_i$, die Tangentialgeschwindigkeit $v_i^{(t)}$ unter gegebenen Anströmwinkel $\alpha $ und -geschwindigkeit $V_{\infty}$, und der resultierende Druckbeiwert $c_{p_i}$.
\begin{lstlisting}[language=Python]
class Panel:

    def __init__(self, xa, ya, xb, yb):
        self.xa, self.ya = xa, ya
        self.xb, self.yb = xb, yb

        self.xm = (xa + xb) / 2
        self.ym = (ya + yb) / 2
        self.length = np.sqrt((xb - xa) ** 2 + (yb - ya) ** 2)
        self.theta = np.arctan2(yb - ya, xb - xa)
        if self.theta < 0:
            self.theta += 2 * np.pi

        self.q = None
        self.vt = None
        self.cp = None
\end{lstlisting}

\subsubsection{Die Klasse AirfoilProfile}
Die Klasse AirfoilProfile modelliert ein gegebenes Profil. Sie speichert neben wählbaren Namen und der ihr zugewiesenen Panele auch die Profiltiefe $t$ und sämtliche Systemparameter $\xi_{ij}, \; \eta_{ij}, \; I_{ij}, \; J_{ij}, \; A_{ij}^{(n)}, \;A_{ij}^{(t)}, \;M_{ij}$. \\
Durch einen Aufruf der Methode .solve(V, a) mit gegebenen $\alpha $ und $V_{\infty}$ werden für alle zugeordneten Panele die Quellstärken, Tangentialgeschwindigkeiten und Druckbeiwerte berechnet (und in den jeweiligen Klassenvariablen abgespeichert). Dabei wird ebenfalls die Genauigkeit der Approximation $\sum q_i l_i$ berechnet. Die Methode kann mit dem Schlüsselwortargument vortex=True aufgerufen werden, wodurch ebenfalls der Auftriebsbeiwert $c_a$, sowie die Wirbelbewegung $\gamma$ \\ berechnet werden.
Die Methode .write\_panels() erzeugt eine .csv-Datei, welche für jedes Panel die Werte $X_i, Y_i \theta_i, l_i$ in eine Zeile schreibt (siehe \nameref{appendix:a}). \\
Die Methode .compute\_free\_vt(x, y, V, a) ermöglicht die Berechnung der Tangentialgeschwindigkeiten an jedem Punkt $(x_i, y_i)$ des Profils. Diese werden als Tupel von der Methode zurückgegeben.
\begin{lstlisting}[language=Python]
class AirfoilProfile:
    def __init__(self, panels, name=None, vortex=True):
        self.panels = panels
        self.name = name
        self.x = [panel.xa for panel in self.panels]
        self.y = [panel.ya for panel in self.panels]
        self.len = len(self.panels)
        self.vortex = vortex

        self.U = sum([panel.length for panel in self.panels])
        self.t = abs(max(self.x) - min(self.x))

        self.xi = comp.xi(self)
        self.eta = comp.eta(self)
        self.I = comp.I(self)
        self.J = comp.J(self)
        self.An = comp.An(self)
        self.At = comp.At(self)
        self.M = comp.M(self)

        self.ca = None
        self.accuracy = None
        self.gamma = None
    def write_panels(self, filename, n=2):
        header = ["X_i", "Y_i", "theta_i", "l_i"]
        with open(filename, "w+", encoding='UTF8',newline="") as file:
            writer = csv.writer(file)
            writer.writerow(header)
            for panel in self.panels:
                writer.writerow([round(panel.xm,n), round(panel.ym,n), round(panel.theta*180/np.pi,n), round(panel.length,n)])

    def solve(self, V=1, a=5):
        a = np.radians(a)
        b = comp.b(self, V, a)

        comp.q(self, b)  # setzt auch self.gamma
        comp.vt(self, V, a)
        comp.cp(self, V)
        comp.ca(self, V)
        comp.accuracy(self)
\end{lstlisting}

\subsubsection{Berechnungsfunktionen der Systemmatrix}
Hier ist die Implementation der Berechnung der Systemmatrix und ihrer Parameter anhand der Funktion xi gezeigt. Die Berechnung der anderen Parameter wurde analog implementiert.
\begin{lstlisting}
def xi(profile):
    panels = profile.panels
    n = len(panels)
    Xi = np.empty((n, n), dtype=float)
    for i in range(n):
        for j in range(n):
            pi, pj = panels[i], panels[j]
            Xi[i][j] = (pi.xm - pj.xm) * np.cos(pj.theta) + (pi.ym - pj.ym) * np.sin(pj.theta)
    return Xi
\end{lstlisting}

\subsubsection{make\_cylinder(r,n)}
Diese Funktion wurde verwendet, um die $x$- und $y$-Koordinaten eines Kreiszylinder mit Radius $r$ und $n$ gleich langen Panels zu generieren. Es wurde dabei besonderes Augenmerk darauf gelegt, dass es an den Endpunkten durch Rundungsfehler nicht zu einem disjunkten Körper kommt.
\begin{lstlisting}
def cylinder(r=1, n=8):
    a = np.linspace(0, 360, num=n+1, endpoint=True) / 180 * np.pi

    x = r * np.cos(a)
    y = r * np.sin(a)
    if abs(x[0] - x[-1]) <= 10 ** (-15):
        x[-1] = x[0]
    if abs(y[0] - y[-1]) <= 10 ** (-15):
        y[-1] = y[0]

    return x, y
\end{lstlisting}

\subsubsection{make\_panels(x,y, reverse=False)}
\begin{lstlisting}
    if type(x) is not np.ndarray:
        x = np.array(x)
    if type(y) is not np.ndarray:
        y = np.array(y)
    if (x[0], y[0]) != (x[-1], y[-1]):
        x = np.append(x, x[0])
        y = np.append(y, y[0])
    if reverse:
        x = np.flipud(x)
        y = np.flipud(y)
    n = len(x) - 1
    panels = np.array([Panel(x[i], y[i], x[i + 1], y[i + 1]) for i in range(n)])
    return panels
\end{lstlisting}

\subsubsection{parsecoords(filename)}
\begin{lstlisting}
    x, y = np.loadtxt(filename, dtype=float, unpack=True)
    return x, y
\end{lstlisting}

\subsubsection{Joukowsky-Profil-Generator}

\begin{lstlisting}
def joukowski_transfrom(zeta):
    z = zeta + 1 / zeta
    return z
def make_joukowski(mux=0.2, muy=0.1, N=100):
    center = -mux + muy * 1j 
    R = np.sqrt((1 + mux) ** 2 + muy ** 2)

    theta = np.linspace(0, 2 * np.pi, N)
    Xc = np.real(center) + R * np.cos(theta)
    Yc = np.imag(center) + R * np.sin(theta)

    p = joukowski_transfrom(Xc + Yc * 1j)
    Xp, Yp = np.real(p), np.imag(p)
    return Xp, Yp, R, muy
\end{lstlisting}

\subsubsection{Kármán-Trefftz-Profil-Generator}

\begin{lstlisting}
def karman_trefftz_transform(zeta, n):
    z = n * ((zeta + 1) ** n + (zeta - 1) ** n) / ((zeta + 1) ** n - (zeta - 1) ** n)
    return z
def make_karman_trefftz(mux=0.2, muy=0.1, n=1.9, N=100):
    center = -mux + muy * 1j
    R = np.sqrt((1 + mux) ** 2 + muy ** 2) 

    theta = np.linspace(0, 2 * np.pi, N)
    Xc = np.real(center) + R * np.cos(theta)
    Yc = np.imag(center) + R * np.sin(theta)
    tx = np.real(center)
    ty = np.imag(center)

    p = karman_trefftz_transform(Xc + Yc * 1j, n)
    Xp, Yp = np.real(p), np.imag(p)
    return Xp, Yp, R, muy
\end{lstlisting}


